# pixel_battle

Набор скриптов, который периодически используется для сохранения состояния
доски и сборки таймлапса VK Pixel Battle.

Готовые таймлапсы [2017-10-10](http://telegra.ph/Polnaya-istoriya-pervoj-pikselnoj-vojny-VKontakte-10-13):

*  [Полный (12 минут, 110МБ)](https://andreymal.org/files/pixel_battle/timelapse.mp4)
*  [Быстрый (17 секунд, 25МБ)](https://andreymal.org/files/pixel_battle/timelapse_fast.mp4)

Готовые таймлапсы 2018-10-10:

*  [Полный (5 минут, 85МБ)](https://andreymal.org/files/pixel_battle/timelapse_2018-10-10.mp4)
*  [Быстрый (23 секунды, 34МБ)](https://andreymal.org/files/pixel_battle/timelapse_2018-10-10_fast.mp4)

Готовые таймлапсы 2019-10-10:

* будут

(Видео закодировано в Lossless H.264, так что его воспроизведёт далеко не любой
плеер и уж тем более не браузер)

Скрипты оформлены в виде Python-модуля:

* `pixel_battle.grabber` — непосредственно сам сборщик. Скачивает картинку
  по адресу `https://pixel.w84.vkforms.ru/api/data/4` каждые несколько секунд
  и сохраняет как оптимизированный PNG в указанный каталог (для примера `img`).
  Умеет проводить дедупликацию с помощью создания симлинков; если симлинков
  на один и тот же файл будет слишком много (более 1440 штук подряд),
  то лишние симлинки удаляются, чтобы не нагружать файловую систему большим
  числом файлов. Так как картика закодирована текстовыми символами, требуется
  предоставить файл с палитрой для декодирования этих символов, а размер
  картинки ожидается 1590x400 пикселей. Использовать примерно так:

        python -m pixel_battle grabber -i 30 --use-symlinks -p palette.json img

  В том же каталоге `img` создаёт файлы `last.json` и `last.png` с информацией
  о последней скачанной картинки и `state.json` со списком симлинков, чтобы
  не забывать их во время перезапуска скрипта.

* `pixel_battle.img2video_prepare` — собирает скачанные grabber'ом картинки из
  каталога `img`, пририсовывает снизу дату (берёт из имени файла) и сохраняет
  в указанный каталог, создавая ffconcat-плейлист, который потом можно скормить
  в ffmpeg. Имена картинок должны быть png и начинаться с `ГГГГ-ММ-ДД_ЧЧ-ММ-СС`.
  Порядок и количество подкаталогов ни на что не влияют — все файлы будут
  отсортированы по имени, которое является временем. Использовать примерно так:

        python -m pixel_battle img2video_prepare img my/src -c my/src.ffcat

  В каталоге `my/src` будут картинки с датами, а в файле `my/src.ffcat` будет
  concat-плейлист, который можно скормить в ffmpeg.

* `pixel_battle.img2video` конвертирует картинки из каталога с картинками
  в какой-нибудь видеофайл. Чтобы даты картинок при этом не потерялись,
  есть опция `--list`, которая позволяет указать файл, в который будут записаны
  оригинальные имена картинок.
  Имена картинок должны начинаться с `ГГГГ-ММ-ДД_ЧЧ-ММ-СС`, сортировка по имени,
  порядок и количество подкаталогов ни на что не влияют.

  Параметры по умолчанию настроены на Lossless VP9 по причине лицензионной
  чистоты, но из практических соображений лучше использовать h264, так как
  libx264rgb жмёт в четыре раза лучше и работает в три раза быстрее.

  Опцией `--format` можно выбрать формат видео:

  * vp9 (по умолчанию) — Lossless VP9, файл webm;
  * h264 — Lossless H.264, файл mp4;
  * h264-main — Lossy H.264 с профилем Main, который осиливают многие устройства
    (однако RGB не поддерживается и качество теряется);
  * h264-baseline — Lossy H.264 с профилем Baseline, который осиливают
    большинство существующих устройств (однако RGB не поддерживается и качество
    теряется);
  * custom — никаких параметров выходного видео не задавать, всё прописывается
    через `--extra-args`.

  Кратко о полезных опциях:

  * `-b 1024k` или `-crf 29` можно использовать для управления качеством
    h264-main или h264-baseline;

  * `--pixfmt rgb24 / yuv420p` позволяет выбрать формат пикселей. Формат `rgb24`
    (по умолчанию) точно сохраняет цвета, но некоторые форматы поддерживают
    только `yuv420p`;

  * `--crop ширина:высота:x:y` для обрезки видео;

  * `--scale 2x` для масштабирования обрезанного видео (без сглаживания);

  * `--begin` и `--end` задют относительные пути к первому и последнему кадрам,
    чтобы не кодировать весь таймлапс целиком.

  Опция `--input-fps` (`-ir`) задаёт частоту кадров входящего видео, а опция
  `--output-fps` (`-or`) изменяет его путём дублирования или выкидывания лишних
  картинок, сохраняя исходную скорость; таким образом `-ir` позволяет управлять
  длительностью получаемого видео.

  Пример кодирования всего таймлапса в Lossless H.264 RGB (в процессе сжатия
  ни один пиксель не пострадает):

        python -m pixel_battle img2video --format h264 \
          ./img/ pixel_battle_2018.mp4 --list pixel_battle_2018.txt

  Сделать таймлапс для старых и немощных устройств и подправить длины
  некоторых кадров файлом 2018.json (используя картинки с датами, нарисованными
  скриптом img2video_prepare):

        python -m pixel_battle img2video --format h264-main -p yuv420p -crf 21 \
          --list pixel_battle_2018.txt --extra 2018.json \
          ./my/src/ pixel_battle_2018_compressed.mp4

  Разглядеть Дерпи поближе и сделать видео для закидывания в телеграм-чатик:

        python -m pixel_battle img2video \
          --begin 2018-10-12_04/2018-10-12_04-20-00.png \
          --end 2018-10-12_07/2018-10-12_07-10-00.png \
          --format h264-baseline -p yuv420p -crf 31 --crop 59:47:100:300 \
          --scale=2x -ir 60 -or 30 ./img/ ./derpy.mp4

* `pixel_battle.video2img` выполняет обратную операцию: читает видеофайл
  и сохраняет кадры в файлы в соответствии с файликом, который был создан
  с аргументом `--list` предыдущим скриптом:

        python -m pixel_battle video2img --use-symlinks \
          pixel_battle_2018.txt pixel_battle_2018.mp4 ./restored_img/

  Если на видео есть часы внизу, то их можно обрезать опцией
  `--crop 1590:400:0:0`. Обратите внимание, что обрезка работает как фильтр
  ffmpeg, поэтому при установке нестандартного размера (не 1590x400) вам также
  нужно указать этот размер в опции `--size 666x777` по техническим причинам,
  иначе картинка съедет.

* `pixel_battle.filelist` просто печатает отсортированный список картинок
  с учётом опций `--begin` и `--end` и может использоваться для отладки или
  в шелл-скриптах:

        python -m pixel_battle filelist \
          --begin 2018-10-12_04/2018-10-12_04-20-00.png \
          --end 2018-10-12_07/2018-10-12_07-10-00.png

* `make_timelapse.sh` и `make_fast_timelapse.sh` — с помощью ffmpeg собирают
  кадры из `my/src` в H.264 RGB видео `timelapse.mp4` и
  `timelapse_fast.mp4` соответственно. Для файла `timelapse.mp4` создаётся
  файл `timelapse.txt` с названиями кадров, что позволяет разобрать видео
  обратно на исходные картинки с помощью `video2img` (без потери качества!).
  Это просто обёртки над скриптами `img2video_prepare` и `img2video`.

* `make_preview.sh` принимает `begin` и `end` (можно указать пустые строки
  в кавычках) и создаёт сжатый видеофайл `preview.mp4`, который потом можно
  закинуть в какой-нибудь телеграм. Тоже обёртка над `img2video`.

* `last.html` отдаёт самую свежую картинку, сохранённую первым скриптом.
  (Осторожно, лютейший тяп-ляп и jQuery внутри)

* `rgb_sha256sum.py` — вспомогательный отладочный скрипт, который используется
  аналогично стандартной линуксовой утилите `sha256sum`, только читает
  RGB-картинки и считает хэши от значений пикселей.
