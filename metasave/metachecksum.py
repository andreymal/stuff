#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import sys
import json
import argparse
import hashlib
from typing import Any, Generator, Optional, Iterable, List, Dict, Set, TextIO, BinaryIO


def iter_meta(fp: TextIO) -> Generator[Dict[str, Any], None, None]:
    line = fp.readline().strip()
    jsonl = True
    try:
        json.loads(line)
    except Exception:
        jsonl = False

    fp.seek(0, 0)

    if jsonl:
        for line in fp:
            yield json.loads(line)
    else:
        data = json.load(fp)  # type: Dict[str, Any]
        if not isinstance(data, dict):
            raise ValueError
        for path, meta in data.items():
            yield {'path': path, 'meta': meta}


def checksum_file(
    fp: BinaryIO,
    meta: Dict[str, Any],
) -> Dict[str, str]:
    hashers = {}  # type: Dict[str, Any]
    if 'sha256sum' in meta:
        hashers['sha256sum'] = hashlib.sha256()
    if 'sha1sum' in meta:
        hashers['sha1sum'] = hashlib.sha1()
    if 'md5sum' in meta:
        hashers['md5sum'] = hashlib.md5()

    while True:
        chunk = fp.read(16384)
        if not chunk:
            break
        for hasher in hashers.values():
            hasher.update(chunk)

    failed_hashes = {}  # type: Dict[str, str]

    for hash_type, hasher in hashers.items():
        if hasher.hexdigest() != meta[hash_type]:
            failed_hashes[hash_type] = hasher.hexdigest()

    return failed_hashes


def checksum_meta(
    root_path: str,
    path: str,
    failed_fp: Optional[TextIO] = None,
    notfound_fp: Optional[TextIO] = None,
    verbosity: int = 0
) -> int:
    ok_cnt = 0
    failed_cnt = 0
    notfound_cnt = 0

    with open(path, 'r', encoding='utf-8-sig') as fp:
        for meta in iter_meta(fp):
            if meta['meta'].get('type') != 'file':
                continue
            file_path = os.path.join(root_path, meta['path'])
            try:
                file_fp = open(file_path, 'rb')  # type: BinaryIO
            except Exception as exc:
                notfound_cnt += 1
                if verbosity > 0:
                    print('{!r}: cannot open: {}'.format(meta['path'], exc), file=sys.stderr)
                if notfound_fp is not None:
                    notfound_fp.write(meta['path'] + '\n')
                continue

            try:
                failed_hashes = checksum_file(file_fp, meta['meta'])
                if not failed_hashes:
                    if verbosity > 1:
                        print('{!r}: OK'.format(meta['path']), file=sys.stderr)
                    ok_cnt += 1
                else:
                    if verbosity > 0:
                        print('{!r}: FAIL ({})'.format(meta['path'], ', '.join(failed_hashes)), file=sys.stderr)
                    if failed_fp is not None:
                        failed_fp.write(meta['path'] + '\n')
                    failed_cnt += 1
            finally:
                file_fp.close()

    return failed_cnt + notfound_cnt


def main() -> int:
    parser = argparse.ArgumentParser(description='Verifies checksum using meta file')
    parser.add_argument('--root', default='.', help='root directory for file paths (default: current)')
    parser.add_argument('--failed-list', help='path to output information about wrong checksums')
    parser.add_argument('--notfound-list', help='path to output information about nonexisting files')
    parser.add_argument('-v', '--verbosity', action='count', help='verbose output (-v prints failed files, -vv prints failed and successful)', default=0)
    parser.add_argument('paths', metavar='PATH', nargs='+', help='json or jsonl files that were generated by metasave.py')

    args = parser.parse_args()

    failed_fp = None  # type: Optional[TextIO]
    notfound_fp = None  # type: Optional[TextIO]
    failed_cnt = 0

    try:
        if args.failed_list:
            failed_fp = open(args.failed_list, 'w', encoding='utf-8')
        if args.notfound_list:
            if args.failed_list and os.path.abspath(args.failed_list) == os.path.abspath(args.notfound_list):
                notfound_fp = failed_fp
            else:
                notfound_fp = open(args.notfound_list, 'w', encoding='utf-8')

        for path in args.paths:
            failed_cnt += checksum_meta(args.root, path, failed_fp, notfound_fp, verbosity=args.verbosity)

    finally:
        if failed_fp is not None:
            failed_fp.close()
            if notfound_fp is failed_fp:
                notfound_fp = None
            failed_fp = None
        if notfound_fp is not None:
            notfound_fp.close()
            notfound_fp = None

    if failed_cnt and args.verbosity > 0:
        print("WARNING: there are {} errors".format(failed_cnt), file=sys.stderr)

    return 0 if not failed_cnt else 1


if __name__ == '__main__':
    sys.exit(main())
