#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# pylint: disable=too-many-instance-attributes

import os
import sys
import json
import time
import shlex
import shutil
import argparse
import traceback
from threading import Event
from subprocess import Popen, PIPE, DEVNULL
from urllib.request import Request, urlopen
from urllib.parse import quote


__version__ = '0.0.2'


# Инпуты


class TuneInput:
    priority = 50

    def __init__(self, **kwargs):
        self._last = None

    def grab(self, amtune):
        return None

    def get_last(self, amtune):
        return dict(self._last) if self._last is not None else None

    def get_cached_track(self, amtune):
        return None


class DeadbeefInput(TuneInput):
    priority = 40

    def __init__(self, deadbeef_cmd='deadbeef'):
        super().__init__()
        self.deadbeef_cmd = deadbeef_cmd
        self.deadbeef_args = shlex.split(self.deadbeef_cmd)
        self.deadbeef_args[0] = shutil.which(self.deadbeef_args[0]) or self.deadbeef_args[0]

    def grab(self, amtune):
        player = Popen(self.deadbeef_args + [
            '--nowplaying-tf',
            '%artist% :::::::: %title%',
        ], stdin=DEVNULL, stdout=PIPE, stderr=DEVNULL)
        data = player.communicate()[0].decode('utf-8').strip()
        if not data or data.count(' :::::::: ') != 1:
            self._last = None
            return None

        artist, title = data.split(' :::::::: ', 1)
        if not artist.strip() or not title.strip():
            self._last = None
            return None

        self._last = {
            'artist': artist.strip(),
            'title': title.strip(),
            'src': 'deadbeef',
        }

        return dict(self._last)


class LastfmInput(TuneInput):
    def __init__(self, username, cache_timeout=120):
        import lxml.html  # pylint: disable=unused-variable; just test requirements
        super().__init__()
        self.username = username
        self.cache_timeout = max(0.0, float(cache_timeout))
        self._cache = None

    def grab(self, amtune):
        import lxml.html
        import lxml.etree

        bindata = amtune.download(
            'https://www.last.fm/user/{}/partial/recenttracks?ajax=1'.format(quote(self.username)),
            {'Referer': 'https://www.last.fm/user/{}'.format(quote(self.username))}
        )

        data = bindata.decode('utf-8', 'replace')

        node = lxml.html.fragments_fromstring(data)[0]
        now = node.xpath('//tr[contains(@class, "now-scrobbling")]')
        if not now:
            self._last = None
            return None

        now = now[0]

        # <a> — ссылка на трек есть
        # <span> — ссылки на трек нет
        # Не знаю, почему иногда не бывает ссылок

        artist = now.xpath('td[contains(@class, "chartlist-name")]/span/span[contains(@class, "chartlist-artists")]/a')
        if not artist:
            artist = now.xpath('td[contains(@class, "chartlist-name")]/span/span[contains(@class, "chartlist-artists")]/span')
        title = now.xpath('td[contains(@class, "chartlist-name")]/span/a')
        if not title:
            title = now.xpath('td[contains(@class, "chartlist-name")]/span/span[contains(@class, "link-block-target")]')

        youtube = now.xpath('td[contains(@class, "chartlist-play")]/a')
        youtube = youtube[0].get('data-youtube-id') if youtube else None

        self._last = {
            'artist': artist[0].text.strip(),
            'title': title[0].text.strip(),
            'src': 'lastfm',
            'youtube': youtube,
        }
        self._cache = (time.time(), dict(self._last))
        return dict(self._last)

    def get_cached_track(self, amtune):
        if not self._cache or time.time() - self._cache[0] > self.cache_timeout:
            self._cache = None
            return None
        return self._cache[1]


# Дополнительные обработчики


class TuneProcessor:
    priority = 50

    def __init__(self, **kwargs):
        pass

    def process(self, amtune, track):
        return {}


class YouTubeProcessor(TuneProcessor):
    def __init__(self, saving_image_path=None):
        super().__init__()
        self.saving_image_path = saving_image_path

    def process(self, amtune, track):
        if not self.saving_image_path or not track.get('youtube'):
            return {}

        # Если есть ютуб у ластфма, то в качестве иконки для уведомляшки берём картинку оттуда
        image_url = 'https://i.ytimg.com/vi/{}/mqdefault.jpg'.format(track['youtube'])
        image_data = None
        for _ in range(3):
            try:
                image_data = amtune.download(image_url)
                break
            except IOError:
                time.sleep(0.3)

        if image_data:
            with open(self.saving_image_path, 'wb') as fp:
                fp.write(image_data)
            image_path = self.saving_image_path
        else:
            image_path = None

        return {'image_path': image_path} if image_path else {}


# Оутпуты


class TuneOutput:
    priority = 50

    def __init__(self, **kwargs):
        pass

    def write(self, amtune, track):
        pass


class FileOutput(TuneOutput):
    def __init__(self, path, data, emptydata='', imgdata=None, default_image_path=None, encoding='utf-8', ignoresrc=None, ignored_as_empty=False):
        super().__init__()
        self.path = path
        self.data = data
        self.emptydata = emptydata
        self.imgdata = imgdata
        self.default_image_path = default_image_path
        self.encoding = encoding
        self.ignoresrc = ignoresrc or []
        self.ignored_as_empty = ignored_as_empty

    def write(self, amtune, track):
        if track and track['src'] in self.ignoresrc:
            if not self.ignored_as_empty:
                return
            track = None

        kwargs = {}

        # Собираем инфу
        if track:
            kwargs['artist'] = track['artist']
            kwargs['title'] = track['title']

            image_path = track.get('image_path') or self.default_image_path
            if image_path and self.imgdata is not None:
                datafmt = self.imgdata
                kwargs['image_path'] = image_path
            else:
                datafmt = self.data

        else:
            datafmt = self.emptydata

        if datafmt is None:
            return

        # Экранируем
        for k, v in list(kwargs.items()):
            kwargs[k + '_eschtml'] = esc_html(v)
            kwargs[k + '_esccmd'] = esc_cmd(v)
            kwargs[k + '_esccmdhtml'] = esc_cmd(esc_html(v))  # Нужно для notify-send

        data = datafmt.format(**kwargs)

        with open(self.path, 'w', encoding=self.encoding) as fp:
            fp.write(data)


class CommandOutput(TuneOutput):
    def __init__(self, cmd, emptycmd='', imgcmd=None, default_image_path=None, ignoresrc=None, ignored_as_empty=False):
        super().__init__()
        self.cmd = cmd
        self.emptycmd = emptycmd
        self.imgcmd = imgcmd
        self.default_image_path = default_image_path
        self.ignoresrc = ignoresrc or []
        self.ignored_as_empty = ignored_as_empty

    def write(self, amtune, track):
        if track and track['src'] in self.ignoresrc:
            if not self.ignored_as_empty:
                return
            track = None

        kwargs = {}

        # Собираем инфу
        if track:
            kwargs['artist'] = track['artist']
            kwargs['title'] = track['title']

            image_path = track.get('image_path') or self.default_image_path
            if image_path and self.imgcmd is not None:
                datafmt = self.imgcmd
                kwargs['image_path'] = image_path
            else:
                datafmt = self.cmd

        else:
            datafmt = self.emptycmd

        if datafmt is None:
            return

        # Экранируем
        for k, v in list(kwargs.items()):
            kwargs[k + '_eschtml'] = esc_html(v)
            kwargs[k + '_esccmd'] = esc_cmd(v)
            kwargs[k + '_esccmdhtml'] = esc_cmd(esc_html(v))  # Нужно для notify-send

        # Готовим команду для выполнения
        cmd = datafmt.format(**kwargs)

        # И выполняем
        if cmd and cmd.strip():
            os.system(cmd)


# Основной класс


class AMTune:
    inputs_registry = {
        'deadbeef': DeadbeefInput,
        'lastfm': LastfmInput,
    }

    processors_registry = {
        'youtube': YouTubeProcessor,
    }

    outputs_registry = {
        'file': FileOutput,
        'command': CommandOutput,
    }

    default_headers = {
        'Accept': '*/*',
        'Accept-Language': 'ru,en-US;q=0.8,en;q=0.5,de;q=0.3',
        'Connection': 'close',
        'User-Agent': 'amtune/{}'.format(__version__),
    }

    def __init__(self, verbosity=0):
        self.inputs = []
        self.processors = []
        self.outputs = []

        self.interval = 15.0
        self.interval_offset = 0.05
        self.download_timeout = 15.0
        self.user_agent = None

        self.last_track = None
        self.verbosity = int(verbosity)

        self.quit_event = Event()

        self._listeners = {
            'start': [],          # (amtune: AMTune)
            'input_start': [],    # (amtune: AMTune)
            'input': [],          # (amtune: AMTune, track: Optional[Dict[str, Any]], inp: TuneInput, get_cached: bool)
            'input_end': [],      # (amtune: AMTune, track: Optional[Dict[str, Any]])
            'process_start': [],  # (amtune: AMTune, track: Dict[str, Any])
            'process': [],        # (amtune: AMTune, track: Dict[str, Any], proc: TuneProcessor)
            'process_end': [],    # (amtune: AMTune, track: Dict[str, Any])
            'output_start': [],   # (amtune: AMTune, track: Optional[Dict[str, Any]])
            'output': [],         # (amtune: AMTune, track: Optional[Dict[str, Any]], out: TuneOutput)
            'output_end': [],     # (amtune: AMTune, track: Optional[Dict[str, Any]])
            'done': [],           # (amtune: AMTune, exc: Optional[Exception])
        }

    def subscribe(self, name, listener):
        if name not in self._listeners:
            raise ValueError('Unknown event type: {!r}'.format(name))
        if listener not in self._listeners[name]:
            self._listeners[name].append(listener)

    def unsubscribe(self, name, listener):
        if name not in self._listeners:
            raise ValueError('Unknown event type: {!r}'.format(name))
        if listener in self._listeners[name]:
            self._listeners[name].remove(listener)

    def _call(
        self, name, args=None, kwargs=None
    ):
        args = args or ()
        kwargs = kwargs or {}
        for listener in self._listeners[name]:
            listener(*args, **kwargs)

    def apply_config(self, config):
        if 'interval' in config:
            self.interval = float(config['interval'])

        if 'interval_offset' in config:
            self.interval_offset = float(config['interval_offset'])

        if 'download_timeout' in config:
            self.download_timeout = float(config['download_timeout'])

        if 'user_agent' in config:
            self.user_agent = str(config['user_agent']) if config['user_agent'] else None

        # Запускаем инпуты
        if not config['inputs']:
            raise ValueError('inputs are not set')

        for typ, kwargs in config['inputs'].items():
            if typ not in self.inputs_registry:
                raise ValueError('Unknown input: {!r}'.format(typ))
            inp = self.inputs_registry[typ](**kwargs)
            self.add_input(inp)

        self.sort_inputs()

        # Запускаем дополнительные обработчики
        if config['processors']:
            for typ, kwargs in config['processors'].items():
                if typ not in self.processors_registry:
                    raise ValueError('Unknown processor: {!r}'.format(typ))
                proc = self.processors_registry[typ](**kwargs)
                self.add_processor(proc)

        self.sort_processors()

        # Запускаем оутпуты
        if not config['outputs']:
            raise ValueError('outputs are not set')

        outputs_cfg = config['outputs']
        if isinstance(outputs_cfg, dict):
            outputs_cfg = [(k, v) for k, v in outputs_cfg.items()]

        for typ, kwargs in outputs_cfg:
            if typ not in self.outputs_registry:
                raise ValueError('Unknown output: {!r}'.format(typ))
            out = self.outputs_registry[typ](**kwargs)
            self.add_output(out)

        self.sort_outputs()

    def read_config_file(self, path):
        with open(path, 'r', encoding='utf-8-sig') as fp:
            config = json.load(fp)
        if not isinstance(config, dict):
            raise TypeError('Config must be dict')
        self.apply_config(config)

    @classmethod
    def register_input(cls, name, inp, force=False):
        if not force and name in cls.inputs_registry:
            raise ValueError('Input {!r} is already registered')
        cls.inputs_registry[name] = inp

    def add_input(self, inp):
        if inp not in self.inputs:
            self.inputs.append(inp)

    def sort_inputs(self):
        self.inputs.sort(key=lambda x: x.priority)

    @classmethod
    def register_processor(cls, name, proc, force=False):
        if not force and name in cls.processors_registry:
            raise ValueError('Processor {!r} is already registered')
        cls.processors_registry[name] = proc

    def add_processor(self, proc):
        if proc not in self.processors:
            self.processors.append(proc)

    def sort_processors(self):
        self.processors.sort(key=lambda x: x.priority)

    @classmethod
    def register_output(cls, name, out, force=False):
        if not force and name in cls.outputs_registry:
            raise ValueError('Output {!r} is already registered')
        cls.outputs_registry[name] = out

    def add_output(self, out):
        if out not in self.outputs:
            self.outputs.append(out)

    def sort_outputs(self):
        self.outputs.sort(key=lambda x: x.priority)

    def _process(self):
        if self.verbosity > 0:
            print('[{}]'.format(time.strftime('%Y-%m-%d %H:%M:%S')), end=' ', flush=True)

        # Берём трек из первого инпута, который имеется
        self._call('input_start', (self,))
        track = None
        for inp in self.inputs:
            self._call('input', (self, track, inp, False))
            track = inp.grab(self)
            if track:
                break

        # Если нет ничего, берём кэш, например, ластфма, чтобы показать хоть что-то
        if not track:
            for inp in self.inputs:
                self._call('input', (self, track, inp, True))
                track = inp.get_cached_track(self)
                if track:
                    break

        if track and (not track['artist'] or not track['title']):
            track = None

        self._call('input_end', (self, track))

        # Печатаем дебаг в консоль
        if self.verbosity > 0:
            if track:
                print('{artist} - {title}'.format(**track), end='', flush=True)
            else:
                print('[nothing]', end='', flush=True)

        # Трек не изменился — ничего не делаем
        if tunecmp(track, self.last_track):
            if self.verbosity > 0:
                print('', flush=True)
            return

        if track:
            # Запускаем дополнительные обработчики, которые добавят какую-нибудь
            # полезноту типа картинки с ютуба
            self._call('process_start', (self, track))
            for proc in self.processors:
                self._call('process', (self, track, proc))
                track.update(proc.process(self, track.copy()))
            self._call('process_end', (self, track))

        # Оутпутим
        self._call('output_start', (self, track))
        for out in self.outputs:
            self._call('output', (self, track, out))
            out.write(self, track.copy() if track else None)
        self._call('output_end', (self, track))

        self.last_track = track

        if self.verbosity > 0:
            print('', flush=True)

    def process(self):
        try:
            self._call('start', (self,))
            self._process()
        except Exception as exc:
            self._call('done', (self, exc))
            raise
        else:
            self._call('done', (self, None))

    def stop(self):
        self.quit_event.set()

    def run(self):
        # Проверяем корректность интервала между проверками
        assert self.interval > 0.0

        # И запускаем основной рабочий цикл
        tm = (time.time() // self.interval) * self.interval + self.interval_offset

        while not self.quit_event.is_set():
            try:
                self.process()
            except Exception:
                traceback.print_exc()

            while tm <= time.time():
                tm += self.interval

            sleep_tm = tm - time.time()
            if sleep_tm > 0:
                self.quit_event.wait(sleep_tm)

    def download(self, req, headers=None):
        if isinstance(req, str):
            req = Request(req)

        ready_headers = self.default_headers.copy()
        if self.user_agent:
            ready_headers['User-Agent'] = self.user_agent
        if headers:
            ready_headers.update(headers)
        for k, v in ready_headers.items():
            req.add_header(k, v)

        return urlopen(req, timeout=self.download_timeout).read()


# Утилиты


def tunecmp(info1, info2):
    '''Сравнивает artist и title у этих двух словарей. Возвращает True, если
    совпадают.
    '''

    if bool(info1) != bool(info2):
        return False

    if not info1 and not info2:
        return True

    assert info1 and info2

    return info1.get('artist') == info2.get('artist') and info1.get('title') == info2.get('title')


def esc_cmd(s):
    # Кавычек в начале и в конце нет, использовать примерно так:
    # "'{}'".format(esc_cmd(foo))
    return s.replace("'", "'\"'\"'").replace('\n', ' ')


def esc_html(s):
    return s.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace('"', '&quot;')


# Запускалка


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-c', '--config', default=os.path.expanduser('~/.config/amtune'), help='Path to configuration file (default ~/.config/amtune)')
    parser.add_argument("-v", "--verbosity", action="count", help="verbose output", default=0)
    args = parser.parse_args()

    amtune = AMTune(verbosity=args.verbosity)
    amtune.read_config_file(args.config)

    try:
        amtune.run()
    except (KeyboardInterrupt, SystemExit):
        print()

    return 0


if __name__ == '__main__':
    sys.exit(main())
