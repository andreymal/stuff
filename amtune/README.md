# amtune

Сначала это был просто скрипт для загрузки информации о треке из DeaDBeeF
в Psi+, но потом я прикрутил Last.fm, и понеслось. Данный скрипт позволяет
получить информацию о проигрываем треке из одного из доступных источников
(Last.fm и DeaDBeeF), обработать как-нибудь (скачать картинку ролика на ютубе,
например) и донести результат до мира любым из доступных способов (записать
в файл или выполнить произвольную команду).

При запуске с опцией `--gtk` появляется иконка в трее, меняющая свой цвет
в зависимости от текущего состояния. Полноценного графического интерфейса нет;
писать файл конфигурации нужно вручную.


## Конфигурация

Конфигурация осуществляется через файл `~/.config/amtune`. Это JSON-объект
(словарь), который может содержать следующее:

- `interval` — интервал между запросами информации о треке в секундах. Время
  запроса выравнивается по указанным секундам независимо от времени запуска
  скрипта: например, при значении 15 (по умолчанию) запрос будет выполняться
  в 00, 15, 30 и 45 секунд каждой минуты (кроме первого раза, который
  выполняется в момент запуска).

- `interval_offset` — смещение вышеупомянутого интервала в секундах. Например,
  если для интервала 15 указать смещение 2, запрос будет выполняться в 02, 17,
  32 и 47 секунд каждой минуты.

- `user_agent` — юзерагент, который будет указываться для HTTP-запросов к,
  например, Last.fm.

- `download_timeout` — таймаут ожидания ответа на HTTP-запросы в секундах
  (по умолчанию 15).

- `inputs`, `processors` и `outputs` — словари (`outputs` также может быть
  списком; см. пример ниже), подключающие источники, обработчики и выходы
  соответственно для работы с информацией о треке. В ключах указывается
  название, в значениях — словарь передаваемых параметров. Подробнее обо всём
  ниже.


## Источники (inputs)

Источники достают откуда-нибудь изначальную информацию о треке и дают словарь
с ключами `artist` и `title`, которые потом дополняются обработчиками
и читаются выходами.


### deadbeef

Данный источник запускает консольную команду плеера с `--nowplaying-tf`
и парсит её вывод. Принимает следующий параметр:

- `deadbeef_cmd` — собственно команда, по умолчанию `deadbeef`; разрешены
  дополнительные аргументы


### lastfm

Скачивает страницу пользователя с сайта last.fm и достаёт «scrobbling now».
Помимо стандартных `artist` и `title` также добавляет `youtube` — id ролика
на YouTube при его наличии на last.fm. Параметры:

- `username` — какого пользователя парсим

- `cache_timeout` — иногда скробблинг слетает раньше чем хотелось бы,
  и для большего удобства последний полученный трек продолжает отдаваться
  в обработку некоторое количество секунд после его пропажи с ластфма,
  по умолчанию 120


## Обработчики (processors)

Обработчики получают информацию о треке, которую вернул один из источников,
и нагружают его дополнительной информацией на своё усмотрение. Обработчики
не запускаются, если трека нет.


### youtube

Скачивает картинку-превьюшку видеозаписи с ютуба, которая прикреплена к треку
на last.fm. Добавляет в информацию о треке `image_path`. Работает только если
информация о треке получена от источника lastfm (этот источник парсит id
ролика с ластфма). Параметры:

- `saving_image_path` — куда скачать картинку


## Выходы (outputs)

Берут всё, что напарсили источники и добавили обработчики, и делают с этой
информацией что-нибудь. В отличие от источников или обработчиков, один
и тот же выход вы можете добавить несколько раз, тем самым выполняя самые
разные действия.


### file

Пишет файл по заданному пути в заданном формате. Если есть какая-то картинка
(`image_path` или `default_image_path`), берёт шаблон `imgdata` при наличии,
если нет — то берёт просто `data`. При отсутствии трека всегда берётся шаблон
`emptydata`. Параметры:

- `path` — путь к записываемому файлу (относительно текущего каталога)

- `data` — строка с синтаксисом строковых шаблонов Python, результат рендера
  которой будет записан в файл

- `emptydata` — шаблон, который используется вместо `data`, если трека нет.
  Если прописать пустую строку, то при отсутствии трека будет записываться
  пустой файл. Если прописать null, то не будет сделано ничего, файл не будет
  тронут (по умолчанию пустая строка)

- `imgdata` — шаблон, который используется вместо `data`, когда есть картинка
  к треку (по умолчанию null и используется `data`)

- `default_image_path` — путь к картинке, который будет использоваться
  как `image_path`, если самого `image_path` нету (если указать, то всегда
  будет использоваться шаблон `imgdata` при его наличии и при наличии трека)
  (по умолчанию отсутствует)

- `encoding` — кодировка записываемого файла (по умолчанию utf-8)

- `ignoresrc` — список названий игнорируемых источников, для которых ничего
  с файлом делаться не будет (по умолчанию пуст)

- `ignored_as_empty` — если false (по умолчанию), то при треке
  из игнорируемого источника (`ignoresrc`) не делает вообще ничего. Если true,
  то ведёт себя как при отсутствующем треке, используя шаблон `emptydata`

В строковый шаблон передаются следующие переменные:

- `artist` — исполнитель
- `title` — название трека
- `image_path` — путь к файлу с картинкой (только для `imgdata`)

Также все они доступны с постфиксами:

- `_eschtml` — экранирование HTML-сущностей
- `_esccmd` — экранирование для шелла (использовать внутри одинарных кавычек)
- `_esccmdhtml` экранирование для шелла строки с экранированными
  HTML-сущностями

В шаблон `emptydata` не передаётся ничего.


### command

`command` очень похож на `file`, только вместо записи файла запускает команду.
Параметры:

- `cmd` — строка с синтаксисом строковых шаблонов Python, результат рендера
  которой будет исполнен как команда в консоли (shell)

- `emptycmd` — шаблон, который используется вместо `cmd`, если трека нет
  (по умолчанию пустая строка, не запускающая никакие команды)

- `imgcmd` — шаблон, который используется вместо `cmd`, когда есть картинка
  к треку (по умолчанию null и используется `cmd`)

- `default_image_path` — путь к картинке, который будет использоваться
  как `image_path`, если самого `image_path` нету (если указать, то всегда
  будет использоваться шаблон `imgcmd` при его наличии и при наличии трека)
  (по умолчанию отсутствует)

- `ignoresrc` — список названий игнорируемых источников, для которых ничего
  с файлом делаться не будет (по умолчанию пуст)

- `ignored_as_empty` — если false (по умолчанию), то при треке
  из игнорируемого источника (`ignoresrc`) никаких команд не запускает. Если
  true, то ведёт себя как при отсутствующем треке, используя шаблон `emptycmd`

В строковый шаблон передаются те же переменные, что и в выходе `file`.
Помните, что при использовании экранированных для шелла переменных вроде
`{track_esccmd}` их нужно обязательно использовать в одинарных кавычках!
Примерно так:

    "cmd": "echo '{artist_esccmd} – {track_esccmd}'"


## Пример конфигурации

Примерно такую конфигурацию использую я:

    {
        "inputs": {
            "deadbeef": {},
            "lastfm": {"username": "andreymal31"}
        },

        "processors": {
            "youtube": {"saving_image_path": "/tmp/andreymal_tune_current_img.jpg"}
        },

        "outputs": [
            ["file", {
                "path": "/home/andreymal/.cache/psi+/tune",
                "data": "{title}\n{artist}\n"
            }],
            ["command", {
                "cmd": "notify-send -u low -t 7000 '{title_esccmd}' '{artist_esccmdhtml}'",
                "imgcmd": "notify-send -u low -t 7000 -i '{image_path_esccmd}' '{title_esccmd}' '{artist_esccmdhtml}'",
                "default_image_path": "/home/andreymal/Изображения/lastfm-flat.png",
                "ignoresrc": ["deadbeef"]
            }]
        ]
    }
